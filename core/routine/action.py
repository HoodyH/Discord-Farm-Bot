from typing import Tuple, List
from core.utils.log import Log
from asyncio import (sleep)
from random import (randrange, choices)


class ActionData:

    class SequenceItem:

        def __init__(self, sequence_item_raw):
            self.message: str = sequence_item_raw.get('message')

    def __init__(self, action_raw):
        self._action_raw = action_raw

        self.trigger: str = action_raw.get('trigger')
        self.channels: list = action_raw.get('channels')

        self.loop_time: int = action_raw.get('loop_time', 1800)
        self.loop_range_time: Tuple[int, int] = tuple(action_raw.get('loop_range_time', (120, 600)))
        self.start_range_time: Tuple[int, int] = tuple(action_raw.get('start_range_time', (20, 60)))
        self.execution_probability: int = action_raw.get('execution_probability', 1)

        self.sequence: List[ActionData.SequenceItem] = []
        sequences_raw = action_raw.get('sequence', [])

        for sequence_item_raw in sequences_raw:
            self.sequence.append(ActionData.SequenceItem(sequence_item_raw))


class AutoAction(object):

    def __init__(self, user, action_data: ActionData):
        self.user = user
        self.action_data = action_data

        self.__stop_action = False
        self.__pause_action = False

    def _generate_time_action(self, is_first=False) -> List[Tuple[str, int]]:

        time_actions = []
        total_time = 0
        """
        The 0 key in the farmer_data is consider as init point, 
        the random time generated by the 0 is not counted as total_time (loop time),
        because is a random entry point after the previous cycle.
        
        After that the loop will get and create all the actions after the init point, 
        this actions are part of the total loop time.
        
        The time of this action should not exceed the total loop time.
        If you exceed the loop time the loop will become more longer then expected.
        """
        for idx, sequence_item in enumerate(self.action_data.sequence):

            # on the first call the loop will kick in fast
            if is_first and idx == 0:
                range_min, range_max = self.action_data.start_range_time
            else:
                range_min, range_max = self.action_data.loop_range_time

            # do this action based on execution_probability given
            probability = self.action_data.execution_probability
            do_action = choices([True, False], [probability, 1 - probability])[0]
            if do_action:
                t = randrange(range_min, range_max)
                total_time += t
                time_actions.append((sequence_item.message, t))

        """
        If the actions have not reached the loop time in total_time this section will add the remaining time
        for match the loop time given. If the actions exceed the loop time this value will be 0.
        """
        remaining_time = self.action_data.loop_time - total_time
        if remaining_time > 0:
            time_actions.append((None, remaining_time))

        Log.print_action_log(
            self.user,
            'calculated the loop for this task: "{}"'.format(time_actions)
        )
        return time_actions

    async def start_loop(self, channel, report_channel):

        self.__stop_action = False
        # on the first call the loop will kick in fast
        first_loop = True

        while True:
            if self.__stop_action:
                break

            if not self.__pause_action:

                time_actions = self._generate_time_action(is_first=first_loop)

                action_log = 'calculated the loop for this task: "{}"'.format(time_actions)
                Log.print_action_log(self.user, action_log)
                await report_channel.send(Log.get_action_log(self.user, action_log))

                for action, time in time_actions:

                    typing_time = 0
                    if action:
                        typing_time = int(len(action) / 15)

                    await sleep(time - typing_time)  # time in seconds to send the command

                    if action and not self.__pause_action:
                        await channel.trigger_typing()
                        await sleep(typing_time)
                        await channel.send(action)

                        message_log = f'sent message: "{action}" in location: "{channel}"'
                        Log.print_action_log(self.user, message_log)
                        await report_channel.send(Log.get_action_log(self.user, message_log))

                first_loop = False

            else:
                first_loop = True
                await sleep(1)

    def stop_loop(self):
        self.__stop_action = True

    def pause_loop(self):
        self.__pause_action = True

    def resume_loop(self):
        self.__pause_action = False
